# Block Eater 游戏开发经验总结

本文档记录了 Block Eater 游戏开发过程中遇到的问题和解决方案，供以后开发类似项目参考。

## 目录
1. [中文字体显示问题（最重要）](#中文字体显示问题)
2. [Android 平台开发注意事项](#android-平台开发注意事项)
3. [Raylib 在 Android 上的使用](#raylib-在-android-上的使用)
4. [CI/CD 自动构建配置](#cicd-自动构建配置)
5. [用户系统实现](#用户系统实现)
6. [调试技巧](#调试技巧)
7. [性能优化经验](#性能优化经验)
8. [常见坑点](#常见坑点)

---

## 中文字体显示问题

### 问题描述
在 Android 平台上，中文字符显示为 `???` 或空白方块，即使字体文件存在且加载成功。

### 根本原因
**关键发现**：在 Android 平台上，`LoadFontEx()` 函数无法直接访问 APK assets 目录中的文件。即使 `FileExists()` 返回 true，字体加载也会静默失败。

### 解决方案

#### 错误做法（不工作）
```cpp
// ❌ 这种方式在 Android 上不工作
Font font = LoadFontEx("fonts/zpix.ttf", 20, codepoints, codepointCount);
```

#### 正确做法（工作正常）
```cpp
// ✅ 使用 LoadFileData + LoadFontFromMemory
int fileSize = 0;
unsigned char* fileData = LoadFileData("fonts/zpix.ttf", &fileSize);

if (fileData != nullptr) {
    const char* ext = ".ttf";  // 根据文件类型设置
    pixelFont = LoadFontFromMemory(ext, fileData, fileSize, fontSize, codepoints, codepointCount);
    UnloadFileData(fileData);
}
```

### 完整的字体加载流程
```cpp
// 1. 收集所有需要的文本字符
const char* allChineseText = "方块吞噬者无尽模式关卡模式...";
char allText[4096];
snprintf(allText, sizeof(allText),
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    " !\"#$%%&'()*+,-./:;<=>?@[\\]^_`{|}~%s",
    allChineseText);

// 2. 使用 LoadCodepoints 自动提取唯一字符
int codepointCount = 0;
int* codepoints = LoadCodepoints(allText, &codepointCount);

// 3. 加载字体文件到内存
int fileSize = 0;
unsigned char* fileData = LoadFileData(path, &fileSize);

// 4. 从内存创建字体
const char* ext = (strstr(path, ".ttf") != nullptr) ? ".ttf" : ".otf";
pixelFont = LoadFontFromMemory(ext, fileData, fileSize, fontSize, codepoints, codepointCount);
UnloadFileData(fileData);

// 5. 优化渲染质量
SetTextureFilter(pixelFont.texture, TEXTURE_FILTER_BILINEAR);
GenTextureMipmaps(&pixelFont.texture);

// 6. 清理
UnloadCodepoints(codepoints);
```

### 字符收集策略
- **游戏内文本**：收集所有 UI 中使用的中文文本
- **用户名支持**：包含常用的 500+ 个汉字，支持用户输入中文用户名
- **不要使用全 CJK 范围**：0x4E00-0x9FFF 会消耗太多内存

### 字体文件选择
| 字体 | 大小 | 优点 | 缺点 |
|------|------|------|------|
| zpix.ttf | ~3MB | 像素风格，适合游戏 | 部分生僻字缺失 |
| Source Han Sans | ~7MB | 字符集完整 | 文件较大 |
| vonwaon_bitmap | ~1MB | 文件最小，像素风 | 字符数较少 |

---

## Android 平台开发注意事项

### Native Library 配置

#### 五个必须同步的文件
1. **CMakeLists.txt**
   ```cmake
   add_library(main SHARED ${GAME_SOURCES})
   target_link_libraries(main
       -Wl,--whole-archive
       ${RAYLIB_DIR}/libraylib.a
       -Wl,--no-whole-archive
       android
       log
       GLESv3
       EGL
       OpenSLES
   )
   ```

2. **AndroidManifest.xml**
   ```xml
   <meta-data android:name="android.app.lib_name" android:value="main" />
   ```

3. **build.gradle.kts**
   ```kotlin
   externalNativeBuild {
       cmake {
           arguments += listOf("-DANDROID_STL=c++_shared")
       }
   }
   ```

4. **main.cpp** - 使用标准入口点
   ```cpp
   int main(int argc, char* argv[]) {
       // 游戏代码
   }
   ```
   Raylib 会提供 `android_main()` 包装器

5. **MainActivity.java** - NativeActivity 自动加载
   ```java
   public class MainActivity extends Activity {
       // 不需要手动调用 System.loadLibrary()
   }
   ```

### Assets 访问
- 字体文件放在 `app/src/main/cpp/fonts/`
- 在 `build.gradle.kts` 中配置：
  ```kotlin
  sourceSets {
      getByName("main") {
          assets.srcDirs("src/main/cpp/fonts")
      }
  }
  ```
- 使用 `LoadFileData()` 读取，不能直接用文件路径

### ABI 配置
- 项目只支持 `arm64-v8a`（64位）
- 32位 ABI 在 raylib 5.0 中有 NEON 编译问题

### 权限配置
确保 AndroidManifest.xml 包含必要权限：
```xml
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
```

---

## Raylib 在 Android 上的使用

### 必须使用的编译定义
```cpp
target_compile_definitions(main PRIVATE
    PLATFORM_ANDROID
    GRAPHIC_API_OPENGL_ES_3
    SUPPORT_MODULE_RTEXT
    SUPPORT_MODULE_RAUDIO
)
```

### 初始化顺序
```cpp
void Game::init() {
    // 1. 资源管理器（先初始化）
    assets = new AssetManager();
    assets->init();

    // 2. 音频管理器
    audio = new AudioManager();
    audio->init();

    // 3. 控制系统
    controls = new ControlSystem();
    controls->init();

    // 4. UI 系统（需要字体）
    ui = new UIManager();
    ui->init(&assets->GetPixelFont(), &assets->GetSmallFont());

    // 5. 其他系统
    particles = new ParticleSystem();
    camera = new GameCamera();
    skillManager = new SkillManager();
    userManager = new UserManager();

    // 6. 创建玩家
    player = new Player();
}
```

### 游戏循环
```cpp
void Game::run() {
    while (!WindowShouldClose()) {
        deltaTime = GetFrameTime();
        update();
        draw();
    }
}
```

### 状态管理
使用状态机管理游戏流程：
```cpp
enum class GameState {
    MENU,
    PLAYING,
    PAUSED,
    GAME_OVER,
    LEVEL_SELECT,
    SETTINGS,
    USER_MENU
};

// 切换状态时必须调用
ui->resetTransition();  // 防止屏幕闪烁
```

---

## CI/CD 自动构建配置

### GitHub Actions 关键配置

#### 1. 签名一致性（重要）
```yaml
- name: Cache Android debug keystore
  uses: actions/cache@v4
  with:
    path: ~/.android/debug.keystore
    key: android-debug-keystore-v1

- name: Create debug keystore for consistent signing
  run: |
    mkdir -p ~/.android
    if [ ! -f ~/.android/debug.keystore ]; then
      keytool -genkeypair \
        -keystore ~/.android/debug.keystore \
        -storepass android \
        -keypass android \
        -alias androiddebugkey \
        -keyalg RSA \
        -keysize 2048 \
        -validity 10000 \
        -dname "CN=Android Debug,O=Android,C=US"
    fi
```

这样可以确保每次构建的 APK 签名一致，用户可以直接覆盖安装。

#### 2. 构建错误检测
```yaml
- name: Build APK with Gradle
  run: |
    set -o pipefail
    ./gradlew assembleDebug --no-daemon --no-build-cache --info --stacktrace 2>&1 | tee build-output.log
    # 验证 APK 是否存在
    if [ ! -f "app/build/outputs/apk/debug/app-debug.apk" ]; then
      echo "ERROR: APK not found at expected location!"
      exit 1
    fi
  shell: bash
```

#### 3. 自动发布
```yaml
- name: Create Release
  if: github.ref == 'refs/heads/main' && success()
  uses: softprops/action-gh-release@v1
  with:
    tag_name: build-${{ steps.build_info.outputs.timestamp }}-${{ steps.build_info.outputs.short_sha }}
    name: Block Eater Build ${{ steps.build_info.outputs.timestamp }}
    draft: false
    prerelease: true
```

---

## 用户系统实现

### 数据结构设计
```cpp
struct User {
    char username[64];
    bool isValid;
    int totalGamesPlayed;
    float totalPlayTime;
    int totalScore;
    ModeStats endlessStats;
    ModeStats levelStats;
    ModeStats timeChallengeStats;
    int maxLevelUnlocked;
};

struct ModeStats {
    int highScore;
    int gamesPlayed;
    float playTime;
    int bestLevel;
};
```

### 文件存储格式
- 使用二进制格式存储（`user_data.dat`）
- 文件头使用魔数验证：`0x424C5553` ("BLUS")
- 版本号：当前为 1

### 保存/加载实现要点
```cpp
bool UserManager::saveToFile() {
    FILE* file = fopen(SAVE_FILE_PATH, "wb");
    if (!file) return false;

    // 写入魔数和版本
    uint32_t magic = 0x424C5553;
    fwrite(&magic, sizeof(uint32_t), 1, file);
    uint32_t version = 1;
    fwrite(&version, sizeof(uint32_t), 1, file);

    // 写入用户数据
    fwrite(users, sizeof(User), MAX_USERS, file);

    fclose(file);
    return true;
}
```

### 注意事项
- Android 上文件路径使用相对路径（会自动映射到内部存储）
- 记得在游戏结束时调用保存
- 大值使用 `uint32_t` 避免平台差异

---

## 调试技巧

### Logcat 日志同步到游戏内

使用 `SetTraceLogCallback` 将所有 raylib 日志重定向到游戏内日志查看器：

```cpp
SetTraceLogCallback([](int logLevel, const char* text, va_list args) -> void {
    switch (logLevel) {
        case LOG_INFO: UIManager::logInfo(text); break;
        case LOG_WARNING: UIManager::logWarning(text); break;
        case LOG_ERROR: UIManager::logError(text); break;
        default: UIManager::logInfo(text); break;
    }
});
```

### 日志缓冲区实现
```cpp
// 静态循环缓冲区
static const int MAX_LOG_ENTRIES = 50;
static const int MAX_LOG_LENGTH = 256;
struct LogEntry {
    char message[MAX_LOG_LENGTH];
    int type;  // 0=info, 1=warning, 2=error
};
static LogEntry logBuffer[MAX_LOG_ENTRIES];
static int logIndex = 0;
static int logCount = 0;

// 添加日志
void UIManager::logInfo(const char* message) {
    int idx = logIndex % MAX_LOG_ENTRIES;
    logCount = (logCount < MAX_LOG_ENTRIES) ? logCount + 1 : MAX_LOG_ENTRIES;
    logIndex++;
    snprintf(logBuffer[idx].message, MAX_LOG_LENGTH, "[INFO] %s", message);
    logBuffer[idx].type = 0;
}
```

### 常用调试命令
```bash
# 查看 raylib 相关日志
adb logcat | grep -E "raylib|BlockEater"

# 查看字体加载日志
adb logcat | grep -E "Font|UIManager"

# 实时查看所有日志
adb logcat | grep "com.blockeater"
```

---

## 性能优化经验

### 纹理优化
```cpp
// 使用双线性滤波
SetTextureFilter(pixelFont.texture, TEXTURE_FILTER_BILINEAR);

// 生成 Mipmaps 提升渲染质量
GenTextureMipmaps(&pixelFont.texture);
```

### 编译优化
```cmake
target_compile_options(main PRIVATE
    -O3              # 最高优化级别
    -ffast-math      # 快速数学运算
)
```

### 资源管理
- **程序化生成资源**：背景、方块纹理在运行时生成，减少 APK 大小
- **对象池**：敌人、子弹、粒子使用对象池避免频繁内存分配
- **延迟加载**：只在需要时加载资源

### 渲染优化
```cpp
// 批量绘制相同类型的对象
for (auto* enemy : enemies) {
    enemy->draw();  // 所有敌人一起绘制
}
for (auto* bullet : bullets) {
    bullet->draw();  // 所有子弹一起绘制
}
```

---

## 常见坑点

### 1. 状态切换屏幕闪烁
**问题**：切换游戏状态时屏幕闪一下
**解决**：切换状态时调用 `ui->resetTransition()`

### 2. 技能不显示
**问题**：使用技能后没有效果
**原因**：忘记初始化技能持续时间
```cpp
// ❌ 错误
shieldLevel = 1;
skill.use();

// ✅ 正确
shieldLevel = 1;
shieldTimeLeft = shieldDuration;  // 必须初始化！
skill.use();
```

### 3. 关卡模式立即死亡
**问题**：进入关卡模式立即游戏结束
**原因**：时间限制初始化为 0，第一次更新变成负数
```cpp
// ❌ 错误
timeRemaining = 0;

// ✅ 正确
timeRemaining = level.timeLimit;  // 从配置加载
// 只有 timeLimit > 0 的关卡才检查超时
if (mode == GameMode::LEVEL && timeRemaining > 0) {
    timeRemaining -= deltaTime;
}
```

### 4. 中文字符显示为 ???
**问题**：字体加载成功但中文不显示
**原因**：使用 `LoadFontEx()` 而非 `LoadFontFromMemory()`
**解决**：参考前面的 [中文字体显示问题](#中文字体显示问题)

### 5. 窄化转换编译错误
**问题**：编译时报错 `narrowing conversion from 'int' to 'unsigned int'`
**原因**：C++17 对初始化列表的类型检查更严格
**解决**：使用显式类型转换
```cpp
// ❌ 错误
Color c = {255, 100, 50, 255};  // 可能报错

// ✅ 正确
Color c = {static_cast<unsigned char>(255),
           static_cast<unsigned char>(100),
           static_cast<unsigned char>(50),
           static_cast<unsigned char>(255)};
```

### 6. raygui 按钮不支持中文
**问题**：使用 raygui 的 `GuiButton()` 中文不显示
**原因**：raygui 在 Android 上不支持自定义字体
**解决**：使用自定义的 `UIManager::drawButton()`

---

## 总结

### 开发中的关键经验
1. **字体加载是 Android 开发的最大坑** - 必须使用 `LoadFileData()` + `LoadFontFromMemory()`
2. **状态机管理很重要** - 合理的状态管理让代码更清晰
3. **日志系统必不可少** - 在游戏内查看日志大大提高调试效率
4. **用户系统增加粘性** - 统计和进度让玩家更有动力
5. **CI/CD 节省时间** - 自动构建和发布让迭代更快

### 未来的改进方向
- [ ] 添加更多游戏模式
- [ ] 实现联机对战
- [ ] 添加成就系统
- [ ] 优化 APK 大小（当前约 23MB）
- [ ] 添加音效和背景音乐
- [ ] 实现云存档同步

### 参考资源
- [Raylib 官方文档](https://www.raylib.com/)
- [Raylib GitHub](https://github.com/raysan5/raylib)
- [Android NDK 指南](https://developer.android.com/ndk/guides)
- [项目 GitHub](https://github.com/huuugs/block)

---

**文档版本**: 1.0
**更新日期**: 2025-02-11
**作者**: Block Eater 开发团队
